<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Checker Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f0f2f5;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    canvas {
      border: 4px solid #333;
      border-radius: 8px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      background-color: #fff;
      display: block;
      max-width: 100%;
      height: auto;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      background-color: #ffffff;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
    }
    .message-box {
      background-color: #e0f2f7;
      border: 1px solid #b3e5fc;
      color: #01579b;
      padding: 15px 20px;
      border-radius: 8px;
      font-weight: bold;
      text-align: center;
      min-width: 250px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .reset-button {
      background-color: #4CAF50;
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background-color 0.3s ease, transform 0.2s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .reset-button:hover {
      background-color: #45a049;
      transform: translateY(-2px);
    }
    .reset-button:active {
      transform: translateY(0);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="game-container">
    <h1 class="text-3xl font-bold text-gray-800 mb-4">Checker Game</h1>
    <div id="messageBox" class="message-box">Red's Turn</div>
    <canvas id="checkerboard" width="600" height="600"></canvas>
    <button id="resetButton" class="reset-button">Reset Game</button>
    <audio id="jumpSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_8509567329.mp3?filename=pop-94319.mp3" preload="auto"></audio>
  </div>

  <script>
    const canvas = document.getElementById('checkerboard');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('messageBox');
    const resetButton = document.getElementById('resetButton');
    const jumpSound = document.getElementById('jumpSound');

    const BOARD_SIZE = 8;
    const CELL_SIZE = canvas.width / BOARD_SIZE;

    const LIGHT_SQUARE_COLOR = '#f0d9b5';
    const DARK_SQUARE_COLOR = '#b58863';
    const RED_PIECE_COLOR = '#cc0000';
    const BLACK_PIECE_COLOR = '#333333';
    const SELECTED_COLOR = '#ffeb3b';
    const VALID_MOVE_COLOR = '#8bc34a';

    let board = [];
    let currentPlayer = 'red';
    let selectedPiece = null;
    let possibleMoves = [];
    let isGameOver = false;

    function initializeBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if ((r + c) % 2 !== 0) board[r][c] = 1;
        }
      }
      for (let r = 5; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if ((r + c) % 2 !== 0) board[r][c] = 2;
        }
      }
      currentPlayer = 'red';
      selectedPiece = null;
      possibleMoves = [];
      isGameOver = false;
      updateMessageBox("Red's Turn");
      drawBoard();
    }

    function drawBoard() {
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          ctx.fillStyle = (r + c) % 2 === 0 ? LIGHT_SQUARE_COLOR : DARK_SQUARE_COLOR;
          ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);

          if (selectedPiece && selectedPiece.row === r && selectedPiece.col === c) {
            ctx.fillStyle = SELECTED_COLOR;
            ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }

          if (possibleMoves.some(move => move.row === r && move.col === c)) {
            ctx.fillStyle = VALID_MOVE_COLOR;
            ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }

          const piece = board[r][c];
          if (piece !== 0) {
            ctx.beginPath();
            ctx.arc(c * CELL_SIZE + CELL_SIZE / 2, r * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = (piece === 1 || piece === 3) ? RED_PIECE_COLOR : BLACK_PIECE_COLOR;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (piece === 3 || piece === 4) {
              ctx.fillStyle = 'gold';
              ctx.font = `${CELL_SIZE * 0.5}px Arial`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('â™”', c * CELL_SIZE + CELL_SIZE / 2, r * CELL_SIZE + CELL_SIZE / 2);
            }
          }
        }
      }
    }

    function updateMessageBox(message) {
      messageBox.textContent = message;
    }

    function getPieceType(row, col) {
      return board[row][col];
    }

    function isOwnPiece(row, col) {
      const piece = getPieceType(row, col);
      return currentPlayer === 'red' ? (piece === 1 || piece === 3) : (piece === 2 || piece === 4);
    }

    function isValidMove(startRow, startCol, endRow, endCol) {
      const piece = getPieceType(startRow, startCol);
      const isKing = (piece === 3 || piece === 4);
      const rowDiff = Math.abs(endRow - startRow);
      const colDiff = Math.abs(endCol - startCol);
      const targetCell = getPieceType(endRow, endCol);

      if (rowDiff !== colDiff || targetCell !== 0 || (endRow + endCol) % 2 === 0) return null;

      if (rowDiff === 1) {
        if (currentPlayer === 'red' && !isKing && endRow < startRow) return null;
        if (currentPlayer === 'black' && !isKing && endRow > startRow) return null;
        return { type: 'move' };
      }

      if (rowDiff === 2) {
        const jumpedRow = (startRow + endRow) / 2;
        const jumpedCol = (startCol + endCol) / 2;
        const jumpedPiece = getPieceType(jumpedRow, jumpedCol);
        if (currentPlayer === 'red' && (jumpedPiece === 2 || jumpedPiece === 4)) {
          return { type: 'jump', jumpedPiece: { row: jumpedRow, col: jumpedCol } };
        }
        if (currentPlayer === 'black' && (jumpedPiece === 1 || jumpedPiece === 3)) {
          return { type: 'jump', jumpedPiece: { row: jumpedRow, col: jumpedCol } };
        }
      }
      return null;
    }

    function getPossibleMoves(row, col) {
      const moves = [];
      const piece = getPieceType(row, col);
      const isKing = (piece === 3 || piece === 4);
      const directions = [];

      if (currentPlayer === 'red' || isKing) directions.push({ dr: 1, dc: 1 }, { dr: 1, dc: -1 });
      if (currentPlayer === 'black' || isKing) directions.push({ dr: -1, dc: 1 }, { dr: -1, dc: -1 });

      for (const dir of directions) {
        const newRow = row + dir.dr;
        const newCol = col + dir.dc;

        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE && board[newRow][newCol] === 0) {
          const moveCheck = isValidMove(row, col, newRow, newCol);
          if (moveCheck && moveCheck.type === 'move') {
            moves.push({ row: newRow, col: newCol, type: 'move' });
          }
        }

        const jumpRow = row + 2 * dir.dr;
        const jumpCol = col + 2 * dir.dc;
        if (jumpRow >= 0 && jumpRow < BOARD_SIZE && jumpCol >= 0 && jumpCol < BOARD_SIZE && board[jumpRow][jumpCol] === 0) {
          const moveCheck = isValidMove(row, col, jumpRow, jumpCol);
          if (moveCheck && moveCheck.type === 'jump') {
            moves.push({ row: jumpRow, col: jumpCol, type: 'jump', jumpedPiece: moveCheck.jumpedPiece });
          }
        }
      }
      return moves;
    }

    function animateMove(fromRow, fromCol, toRow, toCol, callback) {
      const piece = board[fromRow][fromCol];
      const frames = 10;
      let frame = 0;

      function step() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();

        const x = fromCol * CELL_SIZE + (toCol - fromCol) * CELL_SIZE * (frame / frames) + CELL_SIZE / 2;
        const y = fromRow * CELL_SIZE + (toRow - fromRow) * CELL_SIZE * (frame / frames) + CELL_SIZE / 2;

        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = (piece === 1 || piece === 3) ? RED_PIECE_COLOR : BLACK_PIECE_COLOR;
        ctx.fill();
        ctx.stroke();

        frame++;
        if (frame <= frames) {
          requestAnimationFrame(step);
        } else {
          callback();
        }
      }
      step();
    }

    function makeMove(startRow, startCol, endRow, endCol) {
      const moveDetails = isValidMove(startRow, startCol, endRow, endCol);
      animateMove(startRow, startCol, endRow, endCol, () => {
        const piece = board[startRow][startCol];
        board[endRow][endCol] = piece;
        board[startRow][startCol] = 0;

        if (moveDetails && moveDetails.type === 'jump') {
          board[moveDetails.jumpedPiece.row][moveDetails.jumpedPiece.col] = 0;
          jumpSound.currentTime = 0;
          jumpSound.play();
        }

        if (piece === 1 && endRow === BOARD_SIZE - 1) board[endRow][endCol] = 3;
        else if (piece === 2 && endRow === 0) board[endRow][endCol] = 4;

        afterMove(endRow, endCol, moveDetails?.type === 'jump');
      });
    }

    function afterMove(endRow, endCol, jumped) {
      selectedPiece = null;
      possibleMoves = [];

      if (jumped) {
        const furtherJumps = getPossibleMoves(endRow, endCol).filter(m => m.type === 'jump');
        if (furtherJumps.length > 0) {
          selectedPiece = { row: endRow, col: endCol };
          possibleMoves = furtherJumps;
          updateMessageBox(`${currentPlayer === 'red' ? 'Red' : 'Black'} must jump again!`);
          drawBoard();
          return;
        }
      }

      currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
      updateMessageBox(`${currentPlayer === 'red' ? 'Red' : 'Black'}'s Turn`);
      drawBoard();
    }

    canvas.addEventListener('click', e => {
      if (isGameOver) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / CELL_SIZE);
      const row = Math.floor(y / CELL_SIZE);
      const clickedPiece = getPieceType(row, col);

      if (selectedPiece) {
        const move = possibleMoves.find(m => m.row === row && m.col === col);
        if (move) {
          makeMove(selectedPiece.row, selectedPiece.col, row, col);
        } else if (isOwnPiece(row, col)) {
          selectedPiece = { row, col };
          possibleMoves = getPossibleMoves(row, col);
        } else {
          selectedPiece = null;
          possibleMoves = [];
        }
      } else if (isOwnPiece(row, col)) {
        selectedPiece = { row, col };
        possibleMoves = getPossibleMoves(row, col);
      }
      drawBoard();
    });

    resetButton.addEventListener('click', initializeBoard);
    window.onload = initializeBoard;
  </script>
</body>
</html>
